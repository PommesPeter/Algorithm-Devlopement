# Chapter1 Basic Algorithm

> 刷题小技巧: 如果输入数据量大于1000000的话建议使用scanf和printf进行输入输出
> 任何有规律的重复运算都能被化简

## 排序
### quicksort(快速排序)
> 一般现场手写的会考
#### 算法流程
1. 确定分界点
   + 直接取左边界
   + 直接取右边界
   + 取中间
   + 随机
2. 调整区间
   + 区间左边的数都小于等于x，区间右边的数都大于等于x
3. 递归处理左右两段区间
   + 一次处理左边的区间，然后再处理右边的区间
   + 因为每次调用快排函数都会对其进行排序，也就是调用顺序是一直先排序左边，然后在回溯的时候再排右边

不需要开辟额外空间<使用两个指针来扫数组>

#### 算法特点
> 注意传参的边界
x为选择出来的分界点
两个指针i,j，i在左边，j在右边。
当故i的左边的数都是小于x的，j右边的数都是大于x的

### mergesort(归并排序)

#### 算法流程
1. 先把数组分成多个区间，通过多次递归区间长度的中间
2. 递归到最底部后开始回溯的时候就开始合并数组
3. 合并数组的时候在不同区间各取一个元素进行比较，把小的放先放到临时数组
4. 比较完毕后再把剩下没放完的元素放到临时数组里
5. 最后把临时数组里面的数放回原数组

#### 算法特点
1. 第一次递归是长度n的区间，第i次递归的区间则是长度n/i*2的区间
2. 每次都是logn，递归了n次，所以复杂度是nlogn

## 高精度问题
> 一般笔试可能会考
> 
### 存储大整数
- 思路：把数的某一位存到一个数组里
   + 存储的时候第0位存个位比较好
      * 因为做进位的时候在数组末尾补上一个数比较方便
      * 普通数组要在前面添加数，所有元素都要往后移一位，在末尾添加不用移位
### 加法

#### 算法流程
- 核心思路：逐位相加（A[i] + B[i] + t）的时候要把每一位相加的结果的十位和个位分开，个位作为当前的位数，十位作为下一次计算的进位（也就是需要加到A[i+1]+B[i+1]）(这里不是累加，而是直接保存当前的进位)
> 注意区分A<=10和len(A)<=10，一个指的是数，另一个指的是位数
1. 逐位相加
2. 对于每一位来说，都是由$A_i+B_i+t$组成，t为进位。（在个位t=0,其他看情况）
3. 将$A_i+B_i+t$的结果取出其个位作为当前的位数，也就是压入数组
4. 将$A_i+B_i+t$的结果取出其十位作为下一位运算的进位

### 减法

#### 算法流程
- 核心思路：逐位相减（A[i] - B[i] - t）的时候要判断减得的结果，如果小于0则需要往前面借位，即下一次运算的时候要提前先减1，如果没有产生借位就正常计算。此时当前计算位的值为$(t+10)%10$，因为t>=0时就是t本身，t<0时那么就是借10过来，也就是在原来的基础+10即可

1. 逐位相减
2. 比较数的大小确定是否添加符号
3. 对于减法而言，如果相减不够减的时候就要向前面借一位出来
   * 从这里对比加法可以看出，每一位的组成是分两种情况：
      + 如果$A_i-B_i>=0$，则$(A_i-B_i)$
      + 如果$A_i-B_i<0$，则在原来的基础上加上10，则$(A_i-B_i+10)$
   * 对于减法而言，A和B不同的顺序会导致最后计算的值不一样，有两种情况：
      + $A-B>0$，直接减即可
      + $A-B<0$，先计算B-A，再添加负号
   * 总的来说，计算减法主要是把先计算$|A-B|$的值，再根据原来A-B的大小判断是否添加负号
4. 计算完所有位数后处理前导0。

### 乘法

#### 算法流程(乘数为1位)
- 核心思路:

1. 乘数与被乘数的每一位相乘
2. 确定每一位数的值，与加法类似，其值为$(A_i * b)%10$，进位则是$(A_i * b)/10$

## 二分

### 整数二分

### 浮点数二分

## 前缀和与差分

### 前缀和

#### 一维前缀和

前缀和本质上就是一个公式，假设输入一个列表a, 里面元素有$a = \[a_1,a_2,...,a_n\]$，则前缀和为:$s_i=a_1+a_2+...+a_i$.

前缀和的作用: 能够快速求出原数组中一段数的和，如果给定一个区间的两个端点$l,r$，则这个区间内的数的和为$s_r-s_{l - 1}$，用一次计算就能计算出一段和，原本需要$O(n)$的复杂度。

#### 二维前缀和

可以快速求出一个子矩阵里面的和。其中表示为$s_{ij}$，表示左上角的子矩阵的和，也就是表示前i行和前j列的区域内的元素的和。计算公式为:$s_{ij}=s_{i-1j}+s_{ij-1}-s_{i-1j-1}+a_{ij}$

计算边界为$(x_2,y_2)\rarr(x_1,y_1)$的公式为:$s_{x_2y_2}-s_{x_2y_1-1}-s_{x_1-1y_2}-s_{x_1-1y_2}$

### 差分

差分实际上就是求前缀和的逆运算，公式表达为:$a_i=b_1+b_2+...+b_i$。求解差分可以用$b_n=a_n-a_{n-1}(b_1=a_1)$，其中a为前缀和。

差分作用: 对差分数组求前缀和就能得到原数组；指定某个区间的数全部相加同一个数，但是不能使用$O(n)$的复杂度，要求使用$O(1)$的复杂度。这样就可以达到优化时间复杂度的效果。

注意：b数组是空想出来的，假设是一个满足这个性质的数组。假想一个数组，a数组是b数组的前缀和，b数组就是差分数组。

## 双指针算法

> 用的比较多

平时常用的归并排序、快速排序都是双指针算法。双指针算法主要有两种应用：双指针维护两个数组；双指针维护一个数组。常规的双重循环暴力遍历复杂度为$O(n^2)$，双指针算法的目的就是为了优化这种暴力遍历的算法，一般优化到$O(n)$

常规代码结构:

```c++
for (int i = 0, j = 0; i < n; i++) {
    while (j < i && check(i, j)) j++;
    
    // ... 每道题目的代码的具体逻辑
}
```

- 双指针算法的核心思想：常规暴力算法优化时间复杂度。
